{"ast":null,"code":"import { S3ExpressIdentityCache } from \"./S3ExpressIdentityCache\";\nimport { S3ExpressIdentityCacheEntry } from \"./S3ExpressIdentityCacheEntry\";\nexport class S3ExpressIdentityProviderImpl {\n  constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {\n    this.createSessionFn = createSessionFn;\n    this.cache = cache;\n  }\n  async getS3ExpressIdentity(awsIdentity, identityProperties) {\n    const key = identityProperties.Bucket;\n    const {\n      cache\n    } = this;\n    const entry = cache.get(key);\n    if (entry) {\n      return entry.identity.then(identity => {\n        const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();\n        if (isExpired) {\n          return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;\n        }\n        const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;\n        if (isExpiringSoon && !entry.isRefreshing) {\n          entry.isRefreshing = true;\n          this.getIdentity(key).then(id => {\n            cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));\n          });\n        }\n        return identity;\n      });\n    }\n    return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;\n  }\n  async getIdentity(key) {\n    await this.cache.purgeExpired().catch(error => {\n      console.warn(\"Error while clearing expired entries in S3ExpressIdentityCache: \\n\" + error);\n    });\n    const session = await this.createSessionFn(key);\n    if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {\n      throw new Error(\"s3#createSession response credential missing AccessKeyId or SecretAccessKey.\");\n    }\n    const identity = {\n      accessKeyId: session.Credentials.AccessKeyId,\n      secretAccessKey: session.Credentials.SecretAccessKey,\n      sessionToken: session.Credentials.SessionToken,\n      expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : undefined\n    };\n    return identity;\n  }\n}\nS3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 60000;","map":{"version":3,"names":["S3ExpressIdentityCache","S3ExpressIdentityCacheEntry","S3ExpressIdentityProviderImpl","constructor","createSessionFn","cache","getS3ExpressIdentity","awsIdentity","identityProperties","key","Bucket","entry","get","identity","then","isExpired","expiration","getTime","Date","now","set","getIdentity","isExpiringSoon","REFRESH_WINDOW_MS","isRefreshing","id","Promise","resolve","purgeExpired","catch","error","console","warn","session","Credentials","AccessKeyId","SecretAccessKey","Error","accessKeyId","secretAccessKey","sessionToken","SessionToken","Expiration","undefined"],"sources":["/home/sv/LazyHacks/study-tracker-ui/node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js"],"sourcesContent":["import { S3ExpressIdentityCache } from \"./S3ExpressIdentityCache\";\nimport { S3ExpressIdentityCacheEntry } from \"./S3ExpressIdentityCacheEntry\";\nexport class S3ExpressIdentityProviderImpl {\n    constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {\n        this.createSessionFn = createSessionFn;\n        this.cache = cache;\n    }\n    async getS3ExpressIdentity(awsIdentity, identityProperties) {\n        const key = identityProperties.Bucket;\n        const { cache } = this;\n        const entry = cache.get(key);\n        if (entry) {\n            return entry.identity.then((identity) => {\n                const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();\n                if (isExpired) {\n                    return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;\n                }\n                const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;\n                if (isExpiringSoon && !entry.isRefreshing) {\n                    entry.isRefreshing = true;\n                    this.getIdentity(key).then((id) => {\n                        cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));\n                    });\n                }\n                return identity;\n            });\n        }\n        return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;\n    }\n    async getIdentity(key) {\n        await this.cache.purgeExpired().catch((error) => {\n            console.warn(\"Error while clearing expired entries in S3ExpressIdentityCache: \\n\" + error);\n        });\n        const session = await this.createSessionFn(key);\n        if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {\n            throw new Error(\"s3#createSession response credential missing AccessKeyId or SecretAccessKey.\");\n        }\n        const identity = {\n            accessKeyId: session.Credentials.AccessKeyId,\n            secretAccessKey: session.Credentials.SecretAccessKey,\n            sessionToken: session.Credentials.SessionToken,\n            expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : undefined,\n        };\n        return identity;\n    }\n}\nS3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 60000;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}